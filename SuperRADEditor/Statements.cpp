#include "StdAfx.h"
#include "Statements.h"
#include "AssignmentExpression.h"


Statements::Statements(void)
{

}

Statements::~Statements(void)
{
	//list<BaseStatement*>::iterator it =  content.begin();
	//while(it != content.end())
	//{
	//	if((*it) != NULL)
	//	{
	//		delete *it;
	//	}
	//	it++;
	//}
}

list<BaseStatement*> Statements::GetContent()
{
    return content;
}

 string Statements::ToString(int nestLevel)
 {
     string str;
     int itemIndex =0;
     int itemCount = content.size();
     for(list<BaseStatement*>::iterator currentIterator = content.begin();currentIterator!=content.end();currentIterator++)
     {
         if(*currentIterator!=NULL)
         {
             str.append((*currentIterator)->ToString(nestLevel));
         }
         else
         {
             str.append("\r\n");
		 }
		 if(itemIndex < itemCount-1)
		 {
			 if((*currentIterator)->Type!=Comments)
			 {
				 if((*currentIterator)->Type == Assignment)
				 {
					 AssignmentExpression* assignmentStatement = (AssignmentExpression*)(*currentIterator);
					 string leftString = assignmentStatement->GetLeftExpression()->ToString();
					 if(leftString.compare("$L.comments.AutoGenerated.byEDITOR") !=0)
					 {
						 str.append(";");
					 }
				 }
				 else 
				 { 
					 str.append(";");
				 }
			 }
			 str.append("\r\n");
		 }
		 itemIndex++;
     }
     return str;
 }

 void Statements::AddStatement(BaseStatement* item)
 {
     content.push_back(item);
 }

 string Statements::ToString()
 {
      string str;
     int itemIndex =0;
     int itemCount = content.size();
     for(list<BaseStatement*>::iterator currentIterator = content.begin();currentIterator!=content.end();currentIterator++)
     {
         if(*currentIterator!=NULL)
         {
             str.append((*currentIterator)->ToString());
         }
         if(itemIndex < itemCount-1)
         {
             str.append(";");
         }
         itemIndex++;
     }
     return str;
 }
